/* eslint-disable */
const __generator = function (thisArg, body) {
  let _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1]
      return t[1]
    },
    trys: [],
    ops: []
  }
  let f
  let y
  let t
  let g
  // eslint-disable-next-line no-return-assign
  return ((g = { next: verb(0), throw: verb(1), return: verb(2) }), g)
  function verb (n) {
    return function (v) {
      return step([n, v])
    }
  }
  function step (op) {
    if (f) throw new TypeError('Generator is already executing.')
    while ((g && ((g = 0), op[0] && (_ = 0)), _)) {
      console.log("STARTING STATE", _, "OP", op)
      try {
        if (
          ((f = 1),
          y &&
            (t =
              op[0] & 2
                ? y.return
                : op[0]
                  ? y.throw || ((t = y.return) && t.call(y), 0)
                  : y.next) &&
            !(t = t.call(y, op[1])).done)
        ) { return t }
        if (((y = 0), t)) op = [op[0] & 2, t.value]
        console.log("This is 't'", t)
        switch (op[0]) {
          case 0:
          case 1:
            t = op
            break
          case 4:
            _.label++
            return { value: op[1], done: false }
          case 5:
            _.label++
            y = op[1]
            op = [0]
            continue
          case 7:
            op = _.ops.pop()
            _.trys.pop()
            continue
          default:
            if (
              !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
              (op[0] === 6 || op[0] === 2)
            ) {
              _ = 0
              continue
            }
            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
              _.label = op[1]
              break
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1]
              t = op
              break
            }
            if (t && _.label < t[2]) {
              _.label = t[2]
              _.ops.push(op)
              break
            }
            if (t[2]) _.ops.pop()
            _.trys.pop()
            continue
        }
        op = body.call(thisArg, _)
      } catch (e) {
        op = [6, e]
        y = 0
      } finally {
        f = t = 0
      }
    }
    if (op[0] & 5) throw op[1]
    return { value: op[0] ? op[1] : undefined, done: true }
  }
}

export function generator(a) {
  return __generator(this, function (_a) {
    switch (_a.label) {
      case 0:
        console.log("statement", 0)
        if (!(a > 1)) return [3 /*break*/, 2];
        return [4 /*yield*/, "a1"];
      case 1:
        console.log("statement", 1)
        _a.sent();
        return [3 /*break*/, 4];
      case 2:
        console.log("statement", 2)
        return [4 /*yield*/, "a2"];
      case 3:
        console.log("statement", 3)
        _a.sent();
        _a.label = 4;
      case 4:
        console.log("statement", 4)
        _a.trys.push([4, 7, 8, 9]);
        if (!(Math.round(a) > 3)) return [3 /*break*/, 6];
        return [4 /*yield*/, "b"];
      case 5:
        console.log("statement", 5)
        _a.sent();
        _a.label = 6;
      case 6:
        console.log("statement", 6)
        return [2 /*return*/, "c"];
      case 7:
        console.log("statement", 7)
        e_1 = _a.sent();
        throw e_1;
      case 8:
        console.log("statement", 8)
        typeof console
        return [7 /*endfinally*/];
      case 9: return [2 /*return*/];
    }
  })
}
